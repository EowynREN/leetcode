class TrieNode:
    def __init__(self, val):
        self.val = val
        self.children = {}
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode(' ')

    def insert(self, word):
        cur = self.root

        for c in word:
            if c in cur.children:
                cur = cur.children[c]
            else:
                newNode = TrieNode(c)
                cur.children[c] = newNode
                cur = newNode

        cur.isWord = True


class Points:
    def __init__(self, x, y):
        self.x = x
        self.y = y


class Solution:
    # @param {char[][]} board a list of lists of char
    # @param {str[]} words a list of string
    # @return {int} an integer

    def __init__(self):
        self.largest = []
        self.board = None
        self.visited = []
        self.trie = Trie()
        self.n = 0
        self.m = 0

    def boggleGame(self, board, words):
        # Write your code here

        self.n = len(board)
        self.m = len(board[0])
        self.board = board
        self.visited = [[False for j in range(self.m)] for i in range(self.n)]

        self.findWords([], [], Points(0, 0), self.trie.root)

        return len(self.largest)

    def findWords(self, words, word, point, trieNode):
        i, j = point.x, point.y

        while i < self.n:
            while j < self.m:
                nextCandidatesIndexes = []
                self.nextWordIndexes(nextCandidatesIndexes, [], Points(i, j), trieNode)

                for indexes in nextCandidatesIndexes:
                    word = ""
                    for index in indexes:
                        self.visited[index.x][index.y] = True
                        word += self.board[index.x][index.y]

                    words.append(word)

                    if len(words) > len(self.largest):
                        del self.largest[:]
                        self.largest += words

                    self.findWords(words, word, Points(i, j), trieNode)

                    for index in indexes:
                        self.visited[index.x][index.y] = False

            y = 0

    def nextWordIndexes(self, candidates, path, point, node):
        x = point.x
        y = point.y

        if x < 0 or x >= self.n or y < 0 or y >= self.m or self.visited[x][y] or not node:
            return

        if node.isWord:
            path.append(Points(x , y))
            candidates.append(list(path))
            return

        for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            self.visited[x][y] = True
            path.append(Points(x, y))

            self.nextWordIndexes(candidates, path, Points(x + dx, y + dy), node.children[self.board[x][y]])

            self.visited[x][y] = False
            del path[-1]